# JavaScript Funcionalmente-Ligero
# Capítulo 10: Asincronía Funcional

En este punto del libro, ya tienes todos los conceptos en bruto para los fundamentos de la PF a la que yo llamo "Programación Funcionalmente-Ligera". En este capítulo, vamos a aplicar estos conceptos a un contexto diferente, pero no presentaremos ideas particularmente nuevas.

Hasta ahora, casi todo lo que hemos hecho es sincrónico, lo que significa que llamamos funciones con entradas inmediatas e inmediatamente recuperamos los valores de salida. Se puede hacer mucho trabajo de esta manera, pero no es suficiente para la totalidad de una aplicación de JS moderna. Para estar verdaderamente preparados para la PF en el mundo real de JS, necesitamos entender PF asincronica.

Nuestro objetivo en este capítulo es expandir nuestro pensamiento sobre la gestión de valores con PF, para extender dichas operaciones a lo largo del tiempo. Veremos que los Observables (¡y las Promesas!) son una gran manera de hacer exactamente eso.

## Tiempo Como Estado

El estado más complicado en toda tu aplicación es el tiempo. Es decir, es mucho más fácil administrar el estado cuando la transición de un estado a otro es inmediata y afirmativamente bajo Tu control. Cuando el estado de tu aplicación cambia implícitamente en respuesta a eventos distribuidos en el tiempo, la administración se vuelve exponencialmente más difícil.

Cada parte de cómo hemos presentado a la PF en este texto ha tenido que ver con hacer que el código sea más fácil de leer al hacerlo más confiable y predecible. Cuando introduces la asincronía en tu programa, esos esfuerzos reciben un gran impacto.

Pero seamos más explícitos: no es el mero hecho de que algunas operaciones no terminen sincrónicamente lo que es preocupante; desencadenar un comportamiento asincrónico es fácil. Es la coordinación de las respuestas a estas acciones, cada una de las cuales tiene el potencial de cambiar el estado de tu aplicación, lo que requiere un tanto de esfuerzo adicional.

Entonces, ¿es mejor para ti que el autor haga ese esfuerzo, o deberías dejar que el lector de tu código descubra cuál será el estado del programa si A termina antes de B, o viceversa? Esa es una pregunta retórica, pero con una respuesta bastante concreta desde mi punto de vista: para tener alguna esperanza de hacer que un código tan complejo sea más legible, el autor tiene que preocuparse mucho más de lo que normalmente lo haría.

### Reduciendo El Tiempo

Uno de los resultados más importantes de los patrones de programación asíncronos es simplificar la gestión del cambio de estado al abstraer el tiempo de nuestra esfera de interés. Para ilustrar esto, primero veamos un escenario donde existe una condición de carrera (también conocida como complejidad de tiempo) y esta deba ser gestionada manualmente:

```js
var IdCliente = 42;
var cliente;

buscarCliente( IdCliente, function enCliente(recordCliente){
    var ordenes = cliente ? cliente.ordenes : null;
    cliente = recordCliente;
    if (ordenes) {
        cliente.ordenes = ordenes;
    }
} );

buscarOrdenes( IdCliente, function enOrdenes(ordenesCliente){
    if (!cliente) {
        cliente = {};
    }
    cliente.ordenes = ordenesCliente;
} );
```

Las devoluciones de llamadas `enCliente(..)` y `enOrdenes(..)` están en una condición de carrera binaria. Suponiendo que ambas se ejecuten, es posible que cualquiera de las dos se ejecute primero, y es imposible predecir qué sucederá.

Si pudiéramos insertar la llamada a `buscarOrdenes(..)` dentro de `enCliente(..)`, nos aseguraríamos de que `enOrdenes(..)` se ejecutara después de `enCliente(..)`. Pero no podemos hacer eso, porque necesitamos que las dos búsquedas ocurran al mismo tiempo.

Por lo tanto, para normalizar esta complejidad de estado basada en el tiempo, utilizamos un emparejamiento de comprobaciones de declaración `if` en las respectivas devoluciones de llamada, junto con un `cliente` de variable externa léxica externa. Cuando se ejecuta cada devolución de llamada, comprueba el estado de `cliente` y, por lo tanto, determina su propio orden relativo; si `cliente` no está configurado para una devolución de llamada, es el primero en ejecutarse, de lo contrario es el segundo.

Este código funciona, pero está lejos de ser ideal en términos de legibilidad. La complejidad del tiempo hace que este código sea más difícil de leer. Usemos en cambio una promesa de JS para factorizar el tiempo fuera de la operación:

```js
var IdCliente = 42;

var promesaCliente = buscarCliente( IdCliente );
var promesaOrdenes = buscarOrdenes( IdCliente );

promesaCliente.then( function enCliente(cliente){
    promesaOrdenes.then( function enOrdenes(ordenes){
        cliente.ordenes = ordenes;
    } );
} );
```

La devolución de llamada `enOrdenes(..)` ahora está dentro de la devolución de llamada `enCliente(..)`, por lo que su orden relativa está garantizada. La concurrencia de las búsquedas se lleva a cabo haciendo que las llamadas `buscarCliente(..)` y `buscarOrdenes(..)` se separen antes de especificar el manejo de la respuesta `then(..)`.

Puede que no sea obvio, pero de otro modo existiría una condición de carrera inherentemente en este fragmento, de no ser por la forma en que se define el comportamiento de las promesas. Si la búsqueda de las `ordenes` termina antes de que `promesaOrdenes.then(..)` se llame para proporcionar una devolución de llamada `enOrdenes(..)`, *algo* necesita ser lo suficientemente inteligente como para mantener esa lista `ordenes` hasta que pueda llamarse `enOrdenes(..)`. De hecho, la misma preocupación podría aplicarse a que `cliente` esté presente antes de que `enCliente(..)` se especifique para recibirlo.

Ese *algo* es el mismo tipo de lógica de complejidad de tiempo que discutimos con el fragmento anterior. Pero no tenemos que preocuparnos por esa complejidad, ni en la redacción de este código ni, lo que es más importante, en su lectura, porque las promesas se ocupan de esa normalización del tiempo por nosotros.

Una Promesa representa un único valor (futuro) de una manera independiente al tiempo. Además, extraer el valor de una promesa es la forma asíncrona de la asignación síncrona (mediante `=`) de un valor inmediato. En otras palabras, una promesa extiende una operación de asignación `=` a lo largo del tiempo, pero de una manera confiable (independiente del tiempo).

Ahora exploraremos de qué manera podemos distribuir de manera similar las varias operaciones de PF sincrónicas de este libro de una forma asincrónica a lo largo del tiempo.

## Ansioso vs Perezoso

Ansioso y perezoso en el ámbito de la informática no son cumplidos o insultos, sino más bien formas de describir si una operación finalizará de inmediato o progresará con el tiempo.

Las operaciones de PF que hemos visto en este texto se pueden caracterizar como ansiosas porque operan sincrónicamente (en este momento) en un valor inmediato discreto o lista/estructura de valores.

Recuerda:

```js
var a = [1,2,3]

var b = a.map( v => v * 2 );

b;          // [2,4,6]
```

Este mapeo de `a` a `b` es ansioso porque opera en todos los valores del array `a` en ese momento, y produce un nuevo array `b`. Si luego modificas `a`, por ejemplo, agregando un nuevo valor al final, nada cambiará con respecto al contenido de `b`. Eso es PF ansiosa.

Pero, ¿cómo se vería tener una operación de PF perezosa? Considera algo como esto:

```js
var a = [];

var b = mapPerezoso( a, v => v * 2 );

a.push( 1 );

a[0];       // 1
b[0];       // 2

a.push( 2 );

a[1];       // 2
b[1];       // 4
```

El `mapPerezoso(..)` que hemos imaginado aquí esencialmente "escucha" al array `a`, y cada vez que se agrega un nuevo valor al final de la misma (con `push(..)`), se ejecuta la función de mapeo `v => v * 2` y el valor transformado es empujado al array `b`.

**Nota:** La implementación de `mapPerezoso(..)` no se ha mostrado porque es una ilustración ficticia, no una operación real. Para lograr este tipo de sincronización de operación perezosa entre `a` y `b`, necesitaremos algo más inteligente que los arrays básicos.

Considera los beneficios de poder emparejar un `a` y `b` juntos, donde en cualquier momento (¡incluso asincrónicamente!) puedes poner un valor en `a`, este se transforma y luego se proyecta en `b`. Ese es el mismo tipo de potencia de PF declarativa de una operación `map(..)`, pero ahora se puede extender con el tiempo; no es necesario que conozcas todos los valores de `a` *en este momento* para establecer el mapeo de `a` a `b`.

## PF Reactiva

To understand how we could create and use a lazy mapping between two sets of values, we need to abstract our idea of list (array) a bit. Let's imagine a smarter kind of array, not one which simply holds values but one which lazily receives and responds (aka "reacts") to values. Consider:

```js
var a = new LazyArray();

var b = a.map( function double(v){
    return v * 2;
} );

setInterval( function everySecond(){
    a.push( Math.random() );
}, 1000 );
```

So far, this snippet doesn't look any different than a normal array. The only unusual thing is that we're used to the `map(..)` running eagerly and immediately producing a `b` array with all the currently mapped values from `a`. The timer pushing random values into `a` is strange, since all those values are coming *after* the `map(..)` call.

But this fictional `LazyArray` is different; it assumes that values will come one at a time, over time; just `push(..)` values in whenever you want. `b` will be a lazy mapping of whatever values eventually end up in `a`.

Also, we don't really need to keep values in `a` or `b` once they've been handled; this special kind of array only holds a value as long as it's needed. So these arrays don't strictly grow in memory usage over time, an important characteristic of lazy data structures and operations. In fact, it's less like an array and more like a buffer.

A normal array is eager in that it holds all of its values right now. A "lazy array" is an array where the values will come in over time.

Since we won't necessarily know when a new value has arrived in `a`, another key thing we need is to be able to listen to `b` to be notified when new values are made available. We could imagine a listener like this:

```js
b.listen( function onValue(v){
    console.log( v );
} );
```

`b` is *reactive* in that it's set up to *react* to values as they come into `a`. There's an FP operation `map(..)` that describes how each value transfers from the origin `a` to the target `b`. Each discrete mapping operation is exactly how we modeled single-value operations with normal synchronous FP, but here we're spreading out the sourcing of values over time.

**Note:** The term most commonly applied to these concepts is Functional Reactive Programming (FRP). I'm deliberately avoiding that term because there's some debate as to whether FP + Reactive genuinely constitutes FRP. We're not going to fully dive into all the implications of FRP here, so I'll just keep calling it reactive FP. Alternately, you could call it evented-FP if that feels less confusing.

We can think of `a` as producing values and `b` as consuming them. So for readability, let's reorganize this snippet to separate the concerns into *producer* and *consumer* roles:

```js
// producer:

var a = new LazyArray();

setInterval( function everySecond(){
    a.push( Math.random() );
}, 1000 );


// **************************
// consumer:

var b = a.map( function double(v){
    return v * 2;
} );

b.listen( function onValue(v){
    console.log( v );
} );
```

`a` is the producer, which acts essentially like a stream of values. We can think of each value arriving in `a` as an *event*. The `map(..)` operation then triggers a corresponding event on `b`, which we `listen(..)` to so we can consume the new value.

The reason we separate the *producer* and *consumer* concerns is so that different parts of our application can be responsible for each concern. This code organization can drastically improve both code readability and maintenance.

### Declarative Time

We're being very careful about how we introduce time into the discussion. Specifically, just as promises abstract time away from our concern for a single asynchronous operation, reactive FP abstracts (separates) time away from a series of values/operations.

From the perspective of `a` (the producer), the only evident time concern is our manual `setInterval(..)` loop. But that's only for demonstration purposes.

Imagine `a` could actually be attached to some other event source, like the user's mouse clicks or keystrokes, websocket messages from a server, etc. In that scenario, `a` doesn't actually have to concern itself with time. It's merely a time-independent conduit for values, whenever they are ready.

From the perspective of `b` (the consumer), we do not know or care when/where the values in `a` come from. As a matter of fact, all the values could already be present. All we care about is that we want those values, whenever they are ready. Again, this is a time-independent (aka lazy) modeling of the `map(..)` transformation operation.

The *time* relationship between `a` and `b` is declarative (and implicit!), not imperative (or explicit).

The value of organizing such operations-over-time this way may not feel particularly effective yet. Let's compare to how this same sort of functionality could have be expressed imperatively:

```js
// producer:

var a = {
    onValue(v){
        b.onValue( v );
    }
};

setInterval( function everySecond(){
    a.onValue( Math.random() );
}, 1000 );


// **************************
// consumer:

var b = {
    map(v){
        return v * 2;
    },
    onValue(v){
        v = this.map( v );
        console.log( v );
    }
};
```

It may seem rather subtle, but there's a important difference between this more-imperative version of the code and the previous more-declarative version, aside from just `b.onValue(..)` needing to call `this.map(..)` itself. In the former snippet, `b` pulls from `a`, but in the latter snippet, `a` pushes to `b`. In other words, compare `b = a.map(..)` to `b.onValue(v)`.

In the latter imperative snippet, it's not clear (readability wise) from the consumer's perspective where the `v` values are coming from. Moreover, the imperative hard coding of `b.onValue(..)` in the middle of producer `a`'s logic is a violation of separation-of-concerns. That can make it harder to reason about producer and consumer independently.

By contrast, in the former snippet, `b = a.map(..)` declares that `b`'s values are sourced from `a`, and treats `a` as an abstract event stream data source that we don't have to concern ourselves with at that moment. We *declare* that any value that comes from `a` into `b` will go through the `map(..)` operation as specified.

### More Than Map

For convenience, we've illustrated this notion of pairing `a` and `b` together over time via a one-to-one `map(..)`ing. But many of our other FP operations could be modeled over time as well.

Consider:

```js
var b = a.filter( function isOdd(v) {
    return v % 2 == 1;
} );

b.listen( function onlyOdds(v){
    console.log( "Odd:", v );
} );
```

Here, a value from `a` only comes into `b` if it passes the `isOdd(..)` predicate.

Even `reduce(..)` can be modeled over time:

```js
var b = a.reduce( function sum(total,v){
    return total + v;
} );

b.listen( function runningTotal(v){
    console.log( "New current total:", v );
} );
```

Since we don't specify an `initialValue` to the `reduce(..)` call, neither the `sum(..)` reducer nor the `runningTotal(..)` event callback will be invoked until at least two values have come through from `a`.

This snippet implies that the reduction has a *memory* of sorts, in that each time a future value comes in, the `sum(..)` reducer will be invoked with whatever the previous `total` was as well as the new next value `v`.

Other FP operations extended over time could even involve an internal buffer, like for example `unique(..)` keeping track of every value it's seen so far.

### Observables

Hopefully by now you can see the importance of a reactive, evented, array-like data structure like the fictional `LazyArray` we've conjured. The good news is, this kind of data structure already exists, and it's called an Observable.

**Note:** Just to set some expectation: the following discussion is only a brief intro to the world of Observables. This is a far more in-depth topic than we have space to fully explore. But if you've understood functional-light programming in this text, and now understood how asynchronous-time can be modeled via FP principles, Observables should follow very naturally for your continued learning.

Observables have been implemented by a variety of userland libraries, most notably RxJS (https://github.com/Reactive-Extensions/RxJS) and Most (https://github.com/cujojs/most). At the time of this writing, there's an in-progress proposal to add Observables natively to JS, just like Promises were added in ES6. For the sake of demonstration, we'll use RxJS-flavored Observables for these next examples.

Here's our earlier reactive example, expressed with observables instead of `LazyArray`:

```js
// producer:

var a = new Rx.Subject();

setInterval( function everySecond(){
    a.next( Math.random() );
}, 1000 );


// **************************
// consumer:

var b = a.map( function double(v){
    return v * 2;
} );

b.subscribe( function onValue(v){
    console.log( v );
} );
```

In the RxJS universe, an Observer subscribes to an Observable. If you combine the functionality of an Observer and an Observable, you get a Subject. So, to keep our snippet simpler, we construct `a` as a Subject, so that we can call `next(..)` on it to push values (events) into its stream.

If we want to keep the Observer and Observable separate:

```js
// producer:

var a = Rx.Observable.create( function onObserve(observer){
    setInterval( function everySecond(){
        observer.next( Math.random() );
    }, 1000 );
} );
```

In this snippet, `a` is the observable, and unsurprisingly, the separate observer is called `observer`; it's able to "observe" some events (like our `setInterval(..)` loop); we use its `next(..)` method to feed events into the `a` observable stream.

In addition to `map(..)`, RxJS defines well over a hundred operators that are invoked lazily as each new value comes in. Just like with arrays, each operator on an Observable returns a new Observable, meaning they are chainable. If an invocation of operator function determines a value should be passed along from the input Observable, it will be fired on the output Observable; otherwise it's discarded.

Example of a declarative observable chain:

```js
var b =
    a
    .filter( v => v % 2 == 1 )      // only odd numbers
    .distinctUntilChanged()         // only consecutive-distinct
    .throttle( 100 )                // slow it down a bit
    .map( v = v * 2 );              // double them

b.subscribe( function onValue(v){
    console.log( "Next:", v );
} );
```

**Note:** It's not necessary to assign the observable to `b` and then call `b.subscribe(..)` separately from the chain; that's done here to reinforce that each operator returns a new observable from the previous one. In many coding examples you'll find, the `subscribe(..)` call is just the final method in the chain. Since `subscribe(..)` is technically mutating the internal state of the observable, FPers generally prefer these two steps separated, to mark the side effect more obviously.

## Summary

This book has detailed a wide variety of FP operations that take a single value (or an immediate list of values) and transform them into another value/values.

For operations that will be proceed over time, all of these foundational FP principles can be applied time-independently. Exactly like promises model single future values, we can model eager lists of values instead as lazy Observable (event) streams of values that may come in one-at-a-time.

A `map(..)` on an array runs its mapping function once for each value currently in the array, putting all the mapped values in the outcome array. A `map(..)` on an Observable runs its mapping function once for each value, whenever it comes in, and pushes all the mapped values to the output Observable.

In other words, if an array is an eager data structure for FP operations, an Observable is its lazy-over-time counterpart.

**Note:** For a different twist on asynchronous FP, check out a library called **fasy**, which is talked about in Appendix C.
